import KERNEL32 VirtualAlloc VirtualAlloc;

struct Ptr {
}

function HeapSystemAlloc(size:uint32):Ptr {
	return VirtualAlloc(0, size, 0x3000, 4);
}

struct CoalesceHeap {
	next:CoalesceHeap,
	elementSize:uint32,
	elementCount:uint32,
	elements:Ptr,
}

function sizeOfCoalesceHeap():uint32 {
		return 4 * 4;
}

function CoalesceHeapHeaderSize(elementCount:uint32):uint32 {
		return sizeOfCoalesceHeap() + (elementCount * sizeOfCoalesceHeapEntry());
}

struct CoalesceHeapEntry {
	used:uint32,
	newBlock:uint32,
}

function sizeOfCoalesceHeapEntry():uint32 {
		return 4 * 2;
}

struct CoalesceHeapElement {
	heap:CoalesceHeap,
	size:uint32,
}

function sizeOfCoalesceHeapElement():uint32 {
		return 4 * 2;
}

function CoalesceHeapSystemAllocAndInit(elementSize:uint32, elementCount:uint32):CoalesceHeap {
	var heap:CoalesceHeap;
	
	heap = HeapSystemAlloc((elementSize * elementCount) + CoalesceHeapHeaderSize(elementCount));
	CoalesceHeapInit(heap, elementSize, elementCount);
	
	return heap;
}

function CoalesceHeapInit(heap:CoalesceHeap, elementSize:uint32, elementCount:uint32):CoalesceHeap {
	(heap.elementSize) = elementSize;
	(heap.elementCount) = elementCount;
	(heap.elements) = heap + CoalesceHeapHeaderSize(elementCount);
	
	return heap;
}

function CoalesceHeapAllocNoNext(heap:CoalesceHeap, size:uint32):Ptr {
	var i:uint32;
	var firstEntry:CoalesceHeapEntry;
	i = 0;
	
	size = size + sizeOfCoalesceHeapElement();
	
	firstEntry = heap + sizeOfCoalesceHeap();
	
	while (i < (heap.elementCount)) {
		var availSize:uint32;
		var j:uint32;
		var entry:CoalesceHeapEntry;
		
		entry = firstEntry;
		j = i;
		availSize = 0;
		
		// Check if we have enough room.
		while ((availSize < size) && (j < (heap.elementCount)) && ((entry.used) == 0)) {
			entry = entry + sizeOfCoalesceHeapEntry();
			availSize = availSize + (heap.elementSize);
			j = j + 1;
		}
		
		// We have enough room!
		if (availSize >= size) {
			(firstEntry.newBlock) = 1;
			
			// Mark used.
			var k:uint32;
			entry = firstEntry;
			k = i;
			while (k < j) {
				(entry.used) = 1;
				entry = entry + sizeOfCoalesceHeapEntry();
				k = k + 1;
			}
			
			var element:CoalesceHeapElement;
			element = (heap.elements) + (i * (heap.elementSize));
			
			(element.heap) = heap;
			(element.size) = size;
			
			var result:Ptr;
			result = element + sizeOfCoalesceHeapElement();
			
			return result;
		}
		
		i = i + 1;
		firstEntry = firstEntry + sizeOfCoalesceHeapEntry();
	}
	return 0;
}

function CoalesceHeapAllocNoHeapAlloc(heap:CoalesceHeap, size:uint32):Ptr {
	var result:Ptr;
	
	result = CoalesceHeapAllocNoNext(heap, size);
	if (result != 0) {
		return result;
	}
	
	while ((heap.next) != 0) {
		heap = heap.next;
		result = CoalesceHeapAllocNoNext(heap, size);
		if (result != 0) {
			return result;
		}
	}
	
	return 0;
}

function CoalesceHeapAllocSystem(heap:CoalesceHeap, size:uint32):Ptr {
	var result:Ptr;
	
	result = CoalesceHeapAllocNoHeapAlloc(heap, size);
	if (result != 0) {
		return result;
	}
	
	(heap.next) = CoalesceHeapSystemAllocAndInit((heap.elementSize), (heap.elementCount));
	return CoalesceHeapAllocNoNext((heap.next), size);
}
